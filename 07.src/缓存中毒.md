# 什么是缓存中毒
前置服务器（cdn等）在用户的恶意请求下改变了某个站点的缓存，导致其他人访问的时候前置服务器返回的是有危害的缓存响应。
Web缓存污染旨在通过攻击者向缓存服务器投递恶意缓存内容，使得用户返回响应结果而触发安全风险。
# 缓存键
缓存键一般包括以下几个组成部分：（）

1. **请求方法**（如 GET, POST）
2. **请求的URL**（包括路径和查询参数）
3. **请求头**（如 Host, Cookie, Authorization 等）

![[缓存中毒1.webp]]
在这张图中，红色部分的URL `/blog/post.php?mobile=1` 确实是缓存键的重要组成部分之一。
# 缓存是如何工作的
由CDN等代理层服务器根据“缓存键”缓存用户请求对应的响应，并在某个请求再次到来时直接返回相应的响应包。例如如下场景中，红色字体标识了缓存服务器配置的缓存键内容，A用户访问服务端返回的结果后，B用户再次访问仅会取得缓存服务器中的内容，因为缓存服务器认为两者是同一个请求，无需再向业务服务端重新请求一次。
# 如何实现缓存中毒
当攻击者的请求中，缓存键和普通用户没有差别，而请求中其它部分存在可体现在响应包中的恶意内容或代码时，该响应被缓存后，其它请求了同一个正常缓存键对应接口的用户会直接得到攻击者提前交给缓存服务器缓存的恶意响应。

以下是一个简单的例子，业务某个接口存在逻辑：获取用户请求Host头的内容，拼接至响应包的js链接中作为访问域名。此时攻击者注入恶意域名[http://hack.com](https://link.zhihu.com/?target=http%3A//hack.com)，受害者访问缓存资源的时候得到的是和攻击者一样的响应结果。此时攻击者通过JavaScript代码几乎劫持了受害者在前端的所有信息和行为，具体的后果则由其中的恶意代码所决定，这与XSS的攻击后果是类似的。![[缓存中毒2.webp]]
Web缓存能够构造什么样的攻击，取决于在不破坏缓存键的同时，构造能够在响应中体现恶意行为的请求，例如业务逻辑对Host头中的值进行校验和请求，但没有校验端口号是否为443或80。此时可以构造请求使得响应跳转至1337端口，其它受害者对该接口的访问便不再可用：![[缓存中毒3.webp]]
# 怎么找缓存键
首先需要确认是否存在缓存键：

- HTTP头直接返回缓存的相关信息
- 观察动态内容的变化
- 返回时间的差异
- 特定的第三方缓存配置头

- 对请求A改动一处成为请求B，各自响应有所差异。若请求B后得到A的缓存结果，则说明A、B的缓存键相同，也说明了改动之处并非缓存键。
- 改变请求A某处内容发送，响应cache头仍然在缓存计时，说明该处内容部分不为缓存键。反之，重新命中，则该处内容包含缓存键。
- 利用特定的头来查询缓存键，例如：Pragma: akamai-x-get-cache-key, akamai-x-get-true-cache-key。
# Web缓存污染防御手段

### 2.1 禁用缓存配置

**对缓存投毒的最强大防御办法就是禁用缓存。**

对于一些人来说，这显然是不切实际的建议，但我推测很多网站开始使用Cloudflare等服务的目的是进行DDoS保护或简化SSL的过程，结果就是容易受到缓存投毒的影响，因为默认情况下缓存是启动的。如果对确定哪些内容是“静态”的足够确认，那么只对纯静态的响应进行缓存也是有效的。

### 2.2 避免从请求中直接获取输入放在响应中

一旦在应用程序中识别出非缓存键的输入，理想的解决方案就是彻底禁用它们。如果不能实现的话可以在缓存层中剥离该输入，或将它们添加到缓存键。建议使用Param Miner等审计应用程序的每个页面以清除非缓存键的输入。