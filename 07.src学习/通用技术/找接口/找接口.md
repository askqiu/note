以下总结自“我们需要从JS文件里提取哪些信息？”微信

webpack压缩js，用packerfuzzer，这个工具会把所有js文件保存到tmp目录中
python PackerFuzzer.py -u https://*** -f 1

由于packerfuzzer在自动测试过程中可能会让你输入接口的“初级目录”，在前后端分离的场景下需要用一些参数指定后端，因此实际上我并不喜欢用packerfuzzer自动测试，我喜欢提取出接口和后端后自己用burp的intruder去测试。因此这里有一个脚本用于处理packerfuzzer下载回来的JS文件
该脚本会匹配被单引号或者双引号包裹起来的字符串，如果字符串被/分割，则将其提取。所以能够很全面地提取js中的接口uri
packerfuzzer+接口脚本（下载+提取）

上图的这个网站，直接查看其前端并没有找到任何和app.js index.js  main.js等比较经典的和webpack相关的文件。然而查看burp的history，却发现该网站加载了app.js，并且unexpected information插件成功在其中匹配到了各种信息
在这种情况下，packerfuzzer可能在一定程度上失灵，但是unexpected information和findsomething却有可能找到我们需要的信息。

fuzz
比如说我们看到http://test.hack.com/api/test/admin/delete，那么是不是可以fuzz一下admin/create呢？

上面我们就分享了从JS中提取接口uri的一些方法，几个现成的工具组合着用就行。

# 接口拼接
通过前面的接口获取，我们可能找到一个/virsical-auth/oauth/token接口
but，我们抓包或者通过别的方法找到的完整请求/vsk/virsical-auth/oauth/token
那么如果我想通过WEB访问这个动作，应该访问的uri应该是：/vsk/virsical-auth/oauth/token
这时候我们猜测他的初级目录是/vsk
找到的其他接口也与/vsk拼接一下，构成完整路径（这就是路径拼接）
当然，所谓"初级路径可能是/vsk也可能是/vsk/virsical-auth/这需要我们测试了
当然实战中绝大部分都是黑盒的情况，你通过现有功能看到这么一个uri，其实也不一定能百分百判断到底哪个是初级uri，比方说上述情况。有可能是/vsk作为初级uri，亦可能是/vsk/virsical-auth/作为初级uri，这个需要靠经验来判断。如果你怕判断有误，最好的办法就是多拼接几次，
- 比如：
- http://test.com/vsk/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/oauth/ <---接口依次拼接在这后面

以此类推，不过一般比较少出现这种情况。上述是“初级目录”的情况，还有一种情况则是前后端分离。这个也很好理解。比方说你访问的网站是：
`http://admin.test.com/#/login然而负责提供服务的后端地址可能是：`
`http://api.admin.test.com/api/admin/login`
`http://admin.test.com:8080/api/admin/login
这些抓包都很容易看出来，就不赘述了。

有些提取到的“接口”uri比其它接口uri显著短得多，而且规则也不一样，很多时候你把他们与后端或者“初级路径”做拼接去请求，却发现直接404了，那么这种是什么呢？这些实际上大部分是前端uri，相信师傅们经常能看到

前后端分离，或者多个初级路径的情况，我们可以写正则匹配http或者https://开头的字符串
> 	其实也非常ez，因为他这些后端地址包括“初级路径”，肯定不是无中生有搞出来的，这些东西肯定都在JS里。比方说上面的那个多个初级路径的情况，在JS中大概率存放了一些地址：http://api.test.com/login/http://api.test.com/user/http://api.test.com/admin/当用户访问对应功能，比方说普通用户修改自己的密码，前端会取出：/userApi/changePwd然后和对应的地址做拼接：http://api.test.com/user/userApi/changePwd然后发起一次请求。因此我们上述提取接口，实际上就是提取了所有类似/userApi/changePwd这样的uri。我们要找后端也很简单，写个正则专门匹配http://或https://开头的字符串即可：   熊猫头也可以实现一部分这样的功能，还有Unexpected information插件

我们获取到所有可能的后端和初级路径之后，我比较喜欢的操作其实是采用笛卡尔积去依此拼接初级路径。简单来说：后端字典 接口字典
http://api1.test.com/                     /user/getinfo
http://api2.test.com/api/admin/            /user/register
 http://api2.test.com/api/                  /manager/changeSetting按照笛卡尔积拼接处理可以得到：
 
 - http://api1.test.com/user/getinfo   
- http://api1.test.com/user/register
- http://api1.test.com/manager/changeSetting
- http://api2.test.com/api/admin/user/getinfo   
- http://api2.test.com/api/admin/user/register
- http://api2.test.com/api/admin/manager/changeSetting
- http://api2.test.com/api/user/getinfo   
- http://api2.test.com/api/user/register
- http://api2.test.com/api/manager/changeSetting
然后我们把这个最终的列表丢给HTTPX之类的工具跑一遍，测测活，根据响应码和数据包长度去筛选出所有可用接口，管他什么后端、初级路径，一下就能找到了，要的就是笨办法！当然这一步要是乐意也可以用burp的Cluster bomb去搞，反正啥工具用得顺手就用啥工具去测活。
综上我们就简单介绍了怎么去提取后端，然后怎么去拼接测试
这些新的地址属于藏得比较深的资产，可以进一步进行全端口扫描，漏扫等

目录fuzz，递归，Tsojanscan、APIKIT等等插件，强烈推荐师傅们使用

还有就是，正则匹配，ak/sk，邮箱，手机号，身份证，ip，密码，注释

# 找参数
有了接口，不给他参数，一般接口是无法正常工作的
example：
开始之前还是先来看看找不到参数是怎样的情况。我们来模拟一下平时测试的流程。我们找到了一个接口，先以GET去访问。一般会提示405，或者回显GET not supported，就是请求方式不对。那我们改成POST或者其它请求方式试试。此时，如果出现415错误，或者回显application/x-www-form-urlencoded Not supported，那就需要换一下Content-Type，绝大部分情况下，只需要改成application/json，并加上json请求体即可，极少数情况下遇到过xml传参。然后？然后就没有然后了，这下，从响应中我们并不能推断出自己下一步要干什么，当然这里还有可能出现各种奇奇怪怪的异常和回显，比如参数缺失、参数验证失败等等总之，我们应该怎么去寻找参数呢？
![[Pasted image 20240922164955.png]]

arjun去fuzz参数名（多参数），burp爆破参数（多参数的话会很难搞）
除了这样傻傻的去FUZZ参数名，有没有什么方法能比较直白地获取到参数呢？当然是有的，既然网站的功能要正常调用这些接口，说明关键的参数肯定也写在JS里了，我们前文提到的各种工具都会告诉你提取的接口出自哪个JS文件

一个比较有效的寻找参数名的方法就是回到JS原文，先定位到接口在JS代码中的位置，再去分析其前后文，寻找一些比较类似参数名的字符串，然后尝试去测试即可。
那我们就点进对应js文件，搜索部分接口uri，去定位前后文。比如上面的接口dev-api/system/pass/get/email/code
![[Pasted image 20240922165822.png]]
首先离他最近的，是不是就指示了它的传参是get模式。Ok，现在知道传参类型了。那么参数名呢？我们还是在这个接口的周围去看，发现离他最近的有个这个
![[Pasted image 20240922165917.png]]
![[Pasted image 20240922165928.png]]
注意看这几个东西，userName、tenantCode、code、newPassword，这几个东西是不是就特别像参数名？那我们直接来试一试，首先不带参数访问
![[Pasted image 20240922170012.png]]
加上刚才的参数？
![[Pasted image 20240922170018.png]]虽然可能因为一些参数值没写好，所以也没有调用成功，但通过返回结果的变化，说明我们已经找对参数名了，后续再FUZZ参数值即可

## 将js拆分成大字典进行fuzz
上面我们介绍了通过分析JS前后文去寻找参数名，但是有些时候，参数名并不会老老实实的放在目标接口的前后文，各种写法和风格千奇百怪，有时候参数名相关的部分可能和接口相关的部分隔得很远，如果JS基础不好是很难看出来的（更何况这些JS代码没有格式化，密密麻麻的更难看懂）。这种情况下对于不会JS的玩家还有没有什么比较友好的操作呢？当然有，既然参数值无论如何也会在JS里，还有种办法是粗暴地把你下载回来的所有JS文件打散成参数字典，
```
核心正则如下：matches = re.findall(r'[a-zA-Z]+[\w-]*\d*|\d+[\w-]*[a-zA-Z]+|[a-zA-Z]+\.[a-zA-Z]+|\w+\.\d+|[a-zA-Z]+~[a-zA-Z]+|\w+~\d+|\d+-\d+|[a-zA-Z]+-[a-zA-Z]+', line)
```
可以用这个正则替换我在上一篇文章的文末给出的小脚本中的正则，实现提取参数的效果，效果类似下面这样：
![[Pasted image 20240922171037.png]]结合前文提到的Burp或者Arjun进行参数FUZZ即可，虽然也比较耗时耗力，但是成功率还是要高上一些。

## 输入输出找参数
返回商品信息的接口和编辑商品信息的接口，它们操作的对象都是“商品”，那么这两个接口涉及到的参数有极大可能是完全一致的，比方说商品名、价格、商品描述等属性，就算有不一致的参数也会是少数，所以，当操作的类对象一样的时候。参数可以参考

同样去操作userDTO对应的用户属性，实现一个删除用户信息的效果？那假如我要获取用户信息呢？是不是同样也是从数据库查询到用户信息后，生成一个userDTO用户对象，然后将这个对象中的属性返回给用户呢？而最有意思的是，在很多java网站中，输出相关的接口（比如返回商品信息）返回的数据基本都会包含属性（参数名）。这也就意味着，如果我们的输入相关接口（如编辑商品信息）找不到参数名，可以去输出相关接口里找。同时输出相关的接口，其参数一般都比较简单，比较好fuzz，比如提到的/api/shop/selectinfo，也许只需要商品名之类的简单参数。我们可以先观察接口名字，找一组“输入输出接口”，当输入相关接口fuzz不出参数，可以找寻对应的输出相关接口，FUZZ其参数，然后通过观察接口返回的信息，来获取具体的参数值，多说无益，我们来给一个案例。

### 案例
挖掘到了一个接口，根据其名字，是编辑学校信息相关的：
![[Pasted image 20240922172824.png]]
比较难受，找不到参数名，经过fuzz也没有结果。根据“输入输出”这一思想的指导，如果我们把学校信息视作一个类，我们上面有编辑（输入）学校信息相关的接口，那应该也会有输出学校学校信息相关的接口。可以筛查出：
![[Pasted image 20240922172919.png]]
访问该接口，实际上可以看到很多东西：
![[Pasted image 20240922172938.png]]
注意这些fullTeacherAvgPeriod、sso、logo，根据上述理论，这些应该就对应学校信息类中的某些属性，很有可能作为/edit接口的参数，我们直接把这个返回包中的关键部分，粘贴到输入接口去利用，会怎么样呢？
![[Pasted image 20240922173039.png]]成功调用。
# 参数收集之长期建设
前文我们依次介绍了几种搜集参数的方法，其实我们的视角是在不断拓宽的，一开始我们搜集参数纯粹是以攻击者的视角来看待这个问题，后面慢慢拓展到以开发者的视角来看待这个问题。其实还可以再拓宽一点，比较正规一点的开发团队、项目，内部肯定是有很多开发上的规定的，其中当然也包括参数的命名规范、规律。同一个公司的不同业务的各个接口用到的参数，会有相似之处，甚至是相同。因此我们要对某个目标进行长时间的深入测试，其实可以准备一些burp插件，把平时关于该目标相关资产的请求、响应中出现的参数名保存下来，就可以生成一个专属目标的参数名字典。这样，当我们遇到和该目标有关的缺失参数名的测试场景时，就可以用这个专属参数名字典去进行参数的FUZZ了。
Github上也能找到一些干这个事的插件，例如：https://github.com/Giftedboy/ParasCollector

# 修改前端uri鉴权逻辑测试接口未鉴权问题
比如上图中的/login、/menu/list等等，这些都是前端uri。这时候就很开心，我直接进行一个拼接。比如说：http://test.com/#/loginhttp://test.com/login尝试拼接一个http://test.com/#/menu/listhttp://test.com/menu/list尝试去访问这些别的前端uri，看看能不能访问到对应的页面。这样一般也会有三种情况，第一种是目标站点没有任何对前端uri的鉴权。我们这么去访问，能直接看到页面，也不会给你跳转啥的，这时候就可以调用页面上的功能去抓包，分析这些功能点对应的接口的问题了。第二种情况稍微好点，就是你这么去访问，有概率看到要访问的页面闪一下，然后给你重定向回登录页面，这种时候有种拼手速的玩法，在重定向回登录页面之前，浏览器上的刷新按钮会变成这个状态：![[Pasted image 20240922174002.png]]
在他重定向回去之前，快速点一下这个X，那么后续动作就会终止执行，你的页面就会卡住。这时候我们也是开启burp愉快抓包就行。其实就是阻止重定向的思路。

第三种情况就是，我们没法看到想访问的页面，前端要么没反应，要么给你弹出个没有权限，要么直接重定向到/login登录页。这种时候我们又该怎么测试呢？下面的内容就需要一点前端调试和JS分析的基础了，本文不会深入展开，仅作案例介绍。假设这么一个网站，我们提取出一个前端uri为/home （很常见）

案例：
我们自然要尝试访问，一访问，发现直接给我们重定向到登录口
![[Pasted image 20240922174503.png]]
![[Pasted image 20240922174524.png]]
这就说明这个前端至少有两层校验，一层与用户登录状态有关，一层与用户权限有关。怎么办呢？我们在控制台搜索“内测”关键词，定位到用户权限鉴权逻辑。
![[Pasted image 20240922174539.png]]
![[Pasted image 20240922174545.png]]
分析这个局部，我们其实很容易能注意到这里的前端鉴权逻辑。前端获取o.state.account.permission属性，一旦这个属性为false，那么就会提示平台内测这个错误，无法访问到对应的前端uri。那么用户登录状态对应什么属性呢？往上翻一下，不难看出对应o.state.baseInfo.isLogin属性
![[Pasted image 20240922174600.png]]
因此我们可以推测，state中保存了用户的基本信息，比如登录状态、权限等等。因此这里好办了，我们给上述两个位置打上断点，重新访问/home。进入第一个断点
![[Pasted image 20240922174611.png]]
在控制台将其强行改为true，![[Pasted image 20240922174630.png]]
进入下一断![[Pasted image 20240922174638.png]]
同样地，再控制台对其赋值为1
![[Pasted image 20240922174659.png]]
再往下走，此时会跳转到一个contract页面![[Pasted image 20240922174709.png]]
虽然没进入home页面，但是这样，我们就来到了一个原本无法直接访问到的一个前端uri，这样就可以调用它的功能了，看这个页面要填的东西很多，最后的传参肯定巨复杂，就算开发好心告诉你缺了什么参数，你敲都要敲半天，用这种方法测起来就快多了。当然，我们的目的是进入home页面，重定向到这个完善账号信息的页面，说明还是有哪里的鉴权没搞好，我们再回到刚刚的鉴权逻辑部分
![[Pasted image 20240922174720.png]]
可以发现，后续其实还对o.state.account.permission的值做了一个判断，如果值为1，那么会直接进入contract页面。值只要是大于1的整数，其实都可以访问到home页面
![[Pasted image 20240922174731.png]]
因此在控制台将permission改为3![[Pasted image 20240922174757.png]]
再访问home，成功：![[Pasted image 20240922174806.png]]
这样，我们就可以愉快的测试后台的各种功能点了。当然上述操作对不懂JS和前端调试的师傅肯定也不太友好。实际上上述操作和平时测试业务逻辑漏洞中的“修改返回包”操作是有等价关系的。为什么这么说呢？我们重新访问一下home页面，然后在burp抓包，拦截一下返回包。可以看到一个/state_user的后端接口，从这个接口的名字我们其实就知道，它是用来判断一个用户状态的。![[Pasted image 20240922174817.png]]
后你再注意这里的account_state，默认是0。以及这个is_login，默认是false。他们是不是就特别像我们刚刚在JS里分析出来的o.state.account.permission和o.state.baseInfo.isLogin？我们推测这个前端实际上就是从返回包里拿到account_state和is_login，并分别给o.state.account.permission、o.state.baseInfo.isLogin赋值的。因此我们将其分别改为3和true，然后把另一个code改为200，发包![[Pasted image 20240922174831.png]]
还是能看到后台页面。这样虽然操作起来比较简单友好，但是万一目标前端对响应结果的判断设置的比较复杂，那就不是那么好办了，比如我前端判断permission为test123abcdef才为有效，我们常见的改响应包的方法就很难改成这样了，所以还是回到JS去分析调试才能应对大部分奇葩情况，还是比较吃基本功的。

# 参数值
上面我们找到了接口，找到了参数名，绝大部分情况下就可以直接开始测试了，但有些时候我们可能还会面临一些关于参数值的FUZZ问题，但是到这里就很简单了。这部分问题大多数情况下集中于json传参的情况，json传参里常见的类型其实也就是下图这些
![[Pasted image 20240922174914.png]]
a为整型，b为字符串类型，c为布尔类型，d为数组类型，e为对象类型。这几种类型都试一下准没错，而且大多数情况下类型错了后端是要直接抛出异常信息的，从异常信息里就很容易能看出来这个地方要传入什么类型，比如异常里看到xxxxx Object xxxxxx，就可以猜测某个参数可能要传入对象类型的传参。
此外还有一点和传参值限制有关的问题就是我们可能会遇到一些字符串格式化问题。比方说一个
Date=
看到这样的参数名，然后发现自己参数值怎么测都测不对的话，可能是后端对这里传入的字符串做了日期类型的格式化、类型限制或正则匹配，这时候可以考虑传入2024-09-07 12:00:00这样符合格式的字符串。还有些可能出现这种问题的参数，一般都和身份证、手机号、邮箱等个人信息有关。不排除开发者自己设定了一些乱七八糟的字符串格式，这些就得具体情况具体分析了。

# 参数篇结语
在日常测试中，我们找到了一个可能存在未鉴权问题的接口，但找不到对应的参数，确实是个很令人红温的问题，希望这篇分享能帮助师傅们找到参数，可能有一些没有提到，欢迎师傅们补充。本系列目前已经分析了攻击者可以从JS中提取哪些信息，分析了应该如何提取参数名参数值以辅助接口测试，但还有一个很重要的问题没有解决——在不同场景下攻击者应该如何获取JS。因此后续几篇文章会介绍不同场景下获取JS的方法。

# 获取js
简单总结，
packerfuzzer下载
页面源码没有webpack特征，但是burp可以看到加载app.js，使用findsomething或者其他burp插件
页面未加载完成但加载了，然后跳转，用packerfuzzer
直接跳转登录口，试试修改返回包，把登陆状态修改为成功，绕过登陆
新页面如果有新js，可以靠findsomething，找接口
js代码和JS里要请求的接口uri，是通过script标签嵌入在html里的，findsomething
注意不同页面、不同JS之间的关联性，页面到js到页面
古老站fuzz js文件
时光机找js

# 总结自
我们需要从JS文件里提取哪些信息？
应该如何寻找参数的蛛丝马迹？
实战中获取JS文件的各种场景
微信搜索的

tool
https://github.com/rtcatc/Packer-Fuzzer
https://github.com/momosecurity/FindSomething
https://github.com/ScriptKid-Beta/Unexpected_information
https://github.com/gh0stkey/HaE
https://github.com/Tsojan/TsojanScan
https://github.com/API-Security/APIKit