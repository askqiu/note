# 特定上下文解码
客户和服务器在传递数据时候使用各种编码，当需要使用这些数据的时候需要进行解码。例如：查询参数通常在服务端进行url解码，html元素的文本内容则通常在客户端进行html解码

通过上下文推断出你的payload如何被解码，从而尝试一些替代的

# 解码差异

任何基于url的输入在分配给相关变量之前都会进行解码，这意味着对于大多数服务器来说，%22与"是同一个意思，

偶尔，你可能会发现 WAFs 等工具在检查输入时无法正确进行 URL 解码。在这种情况下，你可能会通过编码任何被列入黑名单的字符或单词，简单地走私有效载荷到后端应用程序。例如，在 SQL 注入攻击中，你可能将关键词进行编码，所以 SELECT 变成 %53%45%4C%45%43%54 ，依此类推。

# 双重url编码
由于各种原因，一些服务器会对接收到的任何 URL 进行两次 URL 解码。这本身可能不是问题，前提是任何安全机制在检查输入时也会对输入进行双重解码。否则，这种差异使得攻击者只需对恶意输入进行两次编码，就可以将其走私到后端。

# html编码
在 HTML 文档中，某些字符需要转义或编码，以防止浏览器错误地将它们解释为标记的一部分。这是通过将违规字符替换为带有前缀“&”和后缀“;”的引用来实现的。在许多情况下，可以使用名称来表示引用。例如，序列 &colon; 代表冒号字符。

或者，可以使用字符的十进制或十六进制代码点来提供引用，在这种情况下，分别使用 &#58; 和 &#x3a; 。
在 HTML 文档的特定位置，例如元素中的文本内容或属性的值，浏览器在解析文档时会自动解码这些引用。当在这样位置注入时，你有时可以利用这一点来混淆客户端攻击的载荷，使其避开任何已部署的服务器端防御措施。

如果您仔细观察我们之前示例中的 XSS 攻击载荷，会发现载荷被注入到了一个 HTML 属性中，即 onerror 事件处理器。如果服务器端检查是针对 alert() 载荷进行显式查找，那么如果对其中一个或多个字符进行 HTML 编码，它们可能就注意不到这一点：

```
<img src=x onerror="&#x61;lert(1)">
```
When the browser renders the page, it will decode and execute the injected payload.
当浏览器渲染页面时，它将解码并执行注入的载荷。

有趣的是，在使用十进制或十六进制风格的 HTML 编码时，你可以选择性地在代码点中包含任意数量的前导零。一些 WAF 和其他输入过滤器未能充分考虑到这一点。
如果您的负载在经过 HTML 编码后仍然被阻止，您可能会发现，只需在代码点前加几个零，就可以绕过过滤器：

```
<a href="javascript&#00000000000058;alert(1)">Click me</a>
```

# UNICODE
Unicode 转义序列由前缀 \u 后跟字符的四位十六进制代码组成。例如， \u003a 代表冒号。ES6 还支持使用花括号的新形式的 Unicode 转义： \u{3a} 。
当解析字符串时，大多数编程语言都会解码这些 Unicode 转义字符。这包括浏览器使用的 JavaScript 引擎。当将内容注入字符串上下文时，你可以使用 Unicode 来混淆客户端有效载荷，就像我们在上面的例子中使用 HTML 转义字符一样。

例如，假设你正在尝试利用 DOM XSS 漏洞，其中你的输入被作为字符串传递到 eval() 汇入点。如果您的初始尝试被阻止，请尝试按照以下方式对其中一个字符进行转义：

eval("\u0061lert(1)")

由于这将在服务器端保持编码状态，可能直到浏览器再次解码时才会被发现。

也值得注意的是，ES6 风格的 Unicode 转义同样允许可选的前导零，因此一些 WAF（Web 应用防火墙）可能会被我们用于 HTML 编码的相同技术轻易欺骗。例如：

```
<a href="javascript:\u{00000000061}alert(1)">Click me</a>
```

# 进制
在字符串上下文中注入时，还有一个选项是使用十六进制转义字符，这些字符使用它们的十六进制代码点表示，前面加上 \x 前缀。例如，小写字母 a 表示为 \x61 。

就像 Unicode 转义一样，只要输入被评估为字符串，这些就会在客户端进行解码：
eval("\x61lert")

请注意，有时您也可以使用前缀 0x 以类似方式混淆 SQL 语句。例如， 0x53454c454354 可能被解码成 SELECT 关键字。

八进制转义与十六进制转义的工作方式几乎相同，只是字符引用使用的是八进制数制而不是十六进制数制。这些引用前面有一个独立的反斜杠，这意味着小写字母 a 表示为 \141 。

```
eval("\141lert(1)")
```

# 多重编码混淆
将上面的一起混合用
请注意，您可以将编码组合起来，以多层混淆的方式隐藏您的有效载荷。以下示例中的 javascript: URL 就是这样的例子：

```
<a href="javascript:&bsol;u0061lert(1)">Click me</a>
```

浏览器首先将 &bsol;, 进行 HTML 解码，结果产生一个反斜杠。这会将原本随意的 u0061 字符转换成 Unicode 转义序列 \u0061 ：

```
<a href="javascript:\u0061lert(1)">Click me</a>
```

这是进一步解码以形成可运行的 XSS 攻击载荷：

```
<a href="javascript:alert(1)">Click me</a>
```
显然，以这种方式成功注入有效负载，你需要对输入数据上执行的解码及其顺序有深入的了解。

# SQL CHAR()
尽管这不是一种编码形式，但在某些情况下，您可以使用 CHAR() 函数来混淆您的 SQL 注入攻击。该函数接受一个十进制或十六进制代码点，并返回相应的字符。十六进制代码必须以 0x 开头。例如， CHAR(83) 和 CHAR(0x53) 都返回大写字母 S 。

通过连接返回的值，您可以使用这种方法来混淆被屏蔽的关键词。例如，即使 SELECT 被列入黑名单，以下注入代码最初看起来无害：

CHAR(83)+CHAR(69)+CHAR(76)+CHAR(69)+CHAR(67)+CHAR(84)

然而，当应用程序将其作为 SQL 处理时，它将动态构造 SELECT 关键字并执行注入的查询。

# BURP扫描
扫描指定请求，指定的输入点