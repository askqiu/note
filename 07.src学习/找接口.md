webpack压缩js，用packerfuzzer，这个工具会把所有js文件保存到tmp目录中
python PackerFuzzer.py -u https://*** -f 1

由于packerfuzzer在自动测试过程中可能会让你输入接口的“初级目录”，在前后端分离的场景下需要用一些参数指定后端，因此实际上我并不喜欢用packerfuzzer自动测试，我喜欢提取出接口和后端后自己用burp的intruder去测试。因此这里有一个脚本用于处理packerfuzzer下载回来的JS文件
该脚本会匹配被单引号或者双引号包裹起来的字符串，如果字符串被/分割，则将其提取。所以能够很全面地提取js中的接口uri
packerfuzzer+接口脚本（下载+提取）

上图的这个网站，直接查看其前端并没有找到任何和app.js index.js  main.js等比较经典的和webpack相关的文件。然而查看burp的history，却发现该网站加载了app.js，并且unexpected information插件成功在其中匹配到了各种信息
在这种情况下，packerfuzzer可能在一定程度上失灵，但是unexpected information和findsomething却有可能找到我们需要的信息。

fuzz
比如说我们看到http://test.hack.com/api/test/admin/delete，那么是不是可以fuzz一下admin/create呢？

上面我们就分享了从JS中提取接口uri的一些方法，几个现成的工具组合着用就行。

# 接口拼接
通过前面的接口获取，我们可能找到一个/virsical-auth/oauth/token接口
but，我们抓包或者通过别的方法找到的完整请求/vsk/virsical-auth/oauth/token
那么如果我想通过WEB访问这个动作，应该访问的uri应该是：/vsk/virsical-auth/oauth/token
这时候我们猜测他的初级目录是/vsk
找到的其他接口也与/vsk拼接一下，构成完整路径（这就是路径拼接）
当然，所谓"初级路径可能是/vsk也可能是/vsk/virsical-auth/这需要我们测试了
当然实战中绝大部分都是黑盒的情况，你通过现有功能看到这么一个uri，其实也不一定能百分百判断到底哪个是初级uri，比方说上述情况。有可能是/vsk作为初级uri，亦可能是/vsk/virsical-auth/作为初级uri，这个需要靠经验来判断。如果你怕判断有误，最好的办法就是多拼接几次，
- 比如：
- http://test.com/vsk/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/oauth/ <---接口依次拼接在这后面

以此类推，不过一般比较少出现这种情况。上述是“初级目录”的情况，还有一种情况则是前后端分离。这个也很好理解。比方说你访问的网站是：
`http://admin.test.com/#/login然而负责提供服务的后端地址可能是：`
`http://api.admin.test.com/api/admin/login`
`http://admin.test.com:8080/api/admin/login
这些抓包都很容易看出来，就不赘述了。