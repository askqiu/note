以下总结自“我们需要从JS文件里提取哪些信息？”微信

webpack压缩js，用packerfuzzer，这个工具会把所有js文件保存到tmp目录中
python PackerFuzzer.py -u https://*** -f 1

由于packerfuzzer在自动测试过程中可能会让你输入接口的“初级目录”，在前后端分离的场景下需要用一些参数指定后端，因此实际上我并不喜欢用packerfuzzer自动测试，我喜欢提取出接口和后端后自己用burp的intruder去测试。因此这里有一个脚本用于处理packerfuzzer下载回来的JS文件
该脚本会匹配被单引号或者双引号包裹起来的字符串，如果字符串被/分割，则将其提取。所以能够很全面地提取js中的接口uri
packerfuzzer+接口脚本（下载+提取）

上图的这个网站，直接查看其前端并没有找到任何和app.js index.js  main.js等比较经典的和webpack相关的文件。然而查看burp的history，却发现该网站加载了app.js，并且unexpected information插件成功在其中匹配到了各种信息
在这种情况下，packerfuzzer可能在一定程度上失灵，但是unexpected information和findsomething却有可能找到我们需要的信息。

fuzz
比如说我们看到http://test.hack.com/api/test/admin/delete，那么是不是可以fuzz一下admin/create呢？

上面我们就分享了从JS中提取接口uri的一些方法，几个现成的工具组合着用就行。

# 接口拼接
通过前面的接口获取，我们可能找到一个/virsical-auth/oauth/token接口
but，我们抓包或者通过别的方法找到的完整请求/vsk/virsical-auth/oauth/token
那么如果我想通过WEB访问这个动作，应该访问的uri应该是：/vsk/virsical-auth/oauth/token
这时候我们猜测他的初级目录是/vsk
找到的其他接口也与/vsk拼接一下，构成完整路径（这就是路径拼接）
当然，所谓"初级路径可能是/vsk也可能是/vsk/virsical-auth/这需要我们测试了
当然实战中绝大部分都是黑盒的情况，你通过现有功能看到这么一个uri，其实也不一定能百分百判断到底哪个是初级uri，比方说上述情况。有可能是/vsk作为初级uri，亦可能是/vsk/virsical-auth/作为初级uri，这个需要靠经验来判断。如果你怕判断有误，最好的办法就是多拼接几次，
- 比如：
- http://test.com/vsk/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/oauth/ <---接口依次拼接在这后面

以此类推，不过一般比较少出现这种情况。上述是“初级目录”的情况，还有一种情况则是前后端分离。这个也很好理解。比方说你访问的网站是：
`http://admin.test.com/#/login然而负责提供服务的后端地址可能是：`
`http://api.admin.test.com/api/admin/login`
`http://admin.test.com:8080/api/admin/login
这些抓包都很容易看出来，就不赘述了。

有些提取到的“接口”uri比其它接口uri显著短得多，而且规则也不一样，很多时候你把他们与后端或者“初级路径”做拼接去请求，却发现直接404了，那么这种是什么呢？这些实际上大部分是前端uri，相信师傅们经常能看到

前后端分离，或者多个初级路径的情况，我们可以写正则匹配http或者https://开头的字符串
> 	其实也非常ez，因为他这些后端地址包括“初级路径”，肯定不是无中生有搞出来的，这些东西肯定都在JS里。比方说上面的那个多个初级路径的情况，在JS中大概率存放了一些地址：http://api.test.com/login/http://api.test.com/user/http://api.test.com/admin/当用户访问对应功能，比方说普通用户修改自己的密码，前端会取出：/userApi/changePwd然后和对应的地址做拼接：http://api.test.com/user/userApi/changePwd然后发起一次请求。因此我们上述提取接口，实际上就是提取了所有类似/userApi/changePwd这样的uri。我们要找后端也很简单，写个正则专门匹配http://或https://开头的字符串即可：   熊猫头也可以实现一部分这样的功能，还有Unexpected information插件

我们获取到所有可能的后端和初级路径之后，我比较喜欢的操作其实是采用笛卡尔积去依此拼接初级路径。简单来说：后端字典 接口字典
http://api1.test.com/                     /user/getinfo
http://api2.test.com/api/admin/            /user/register
 http://api2.test.com/api/                  /manager/changeSetting按照笛卡尔积拼接处理可以得到：
 
 - http://api1.test.com/user/getinfo   
- http://api1.test.com/user/register
- http://api1.test.com/manager/changeSetting
- http://api2.test.com/api/admin/user/getinfo   
- http://api2.test.com/api/admin/user/register
- http://api2.test.com/api/admin/manager/changeSetting
- http://api2.test.com/api/user/getinfo   
- http://api2.test.com/api/user/register
- http://api2.test.com/api/manager/changeSetting
然后我们把这个最终的列表丢给HTTPX之类的工具跑一遍，测测活，根据响应码和数据包长度去筛选出所有可用接口，管他什么后端、初级路径，一下就能找到了，要的就是笨办法！当然这一步要是乐意也可以用burp的Cluster bomb去搞，反正啥工具用得顺手就用啥工具去测活。
综上我们就简单介绍了怎么去提取后端，然后怎么去拼接测试
这些新的地址属于藏得比较深的资产，可以进一步进行全端口扫描，漏扫等

目录fuzz，递归，Tsojanscan、APIKIT等等插件，强烈推荐师傅们使用

还有就是，正则匹配，ak/sk，邮箱，手机号，身份证，ip，密码，注释

# 找参数
有了接口，不给他参数，一般接口是无法正常工作的
example：
开始之前还是先来看看找不到参数是怎样的情况。我们来模拟一下平时测试的流程。我们找到了一个接口，先以GET去访问。一般会提示405，或者回显GET not supported，就是请求方式不对。那我们改成POST或者其它请求方式试试。此时，如果出现415错误，或者回显application/x-www-form-urlencoded Not supported，那就需要换一下Content-Type，绝大部分情况下，只需要改成application/json，并加上json请求体即可，极少数情况下遇到过xml传参。然后？然后就没有然后了，这下，从响应中我们并不能推断出自己下一步要干什么，当然这里还有可能出现各种奇奇怪怪的异常和回显，比如参数缺失、参数验证失败等等总之，我们应该怎么去寻找参数呢？
![[Pasted image 20240922164955.png]]

arjun去fuzz参数名（多参数），burp爆破参数（多参数的话会很难搞）
除了这样傻傻的去FUZZ参数名，有没有什么方法能比较直白地获取到参数呢？当然是有的，既然网站的功能要正常调用这些接口，说明关键的参数肯定也写在JS里了，我们前文提到的各种工具都会告诉你提取的接口出自哪个JS文件

一个比较有效的寻找参数名的方法就是回到JS原文，先定位到接口在JS代码中的位置，再去分析其前后文，寻找一些比较类似参数名的字符串，然后尝试去测试即可。
那我们就点进对应js文件，搜索部分接口uri，去定位前后文。比如上面的接口dev-api/system/pass/get/email/code
![[Pasted image 20240922165822.png]]
首先离他最近的，是不是就指示了它的传参是get模式。Ok，现在知道传参类型了。那么参数名呢？我们还是在这个接口的周围去看，发现离他最近的有个这个
![[Pasted image 20240922165917.png]]
![[Pasted image 20240922165928.png]]
注意看这几个东西，userName、tenantCode、code、newPassword，这几个东西是不是就特别像参数名？那我们直接来试一试，首先不带参数访问
![[Pasted image 20240922170012.png]]
加上刚才的参数？
![[Pasted image 20240922170018.png]]虽然可能因为一些参数值没写好，所以也没有调用成功，但通过返回结果的变化，说明我们已经找对参数名了，后续再FUZZ参数值即可

## 将js拆分成大字典进行fuzz
上面我们介绍了通过分析JS前后文去寻找参数名，但是有些时候，参数名并不会老老实实的放在目标接口的前后文，各种写法和风格千奇百怪，有时候参数名相关的部分可能和接口相关的部分隔得很远，如果JS基础不好是很难看出来的（更何况这些JS代码没有格式化，密密麻麻的更难看懂）。这种情况下对于不会JS的玩家还有没有什么比较友好的操作呢？当然有，既然参数值无论如何也会在JS里，还有种办法是粗暴地把你下载回来的所有JS文件打散成参数字典，
```
核心正则如下：matches = re.findall(r'[a-zA-Z]+[\w-]*\d*|\d+[\w-]*[a-zA-Z]+|[a-zA-Z]+\.[a-zA-Z]+|\w+\.\d+|[a-zA-Z]+~[a-zA-Z]+|\w+~\d+|\d+-\d+|[a-zA-Z]+-[a-zA-Z]+', line)
```
可以用这个正则替换我在上一篇文章的文末给出的小脚本中的正则，实现提取参数的效果，效果类似下面这样：
![[Pasted image 20240922171037.png]]结合前文提到的Burp或者Arjun进行参数FUZZ即可，虽然也比较耗时耗力，但是成功率还是要高上一些。