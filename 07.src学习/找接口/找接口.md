以下总结自“我们需要从JS文件里提取哪些信息？”微信

webpack压缩js，用packerfuzzer，这个工具会把所有js文件保存到tmp目录中
python PackerFuzzer.py -u https://*** -f 1

由于packerfuzzer在自动测试过程中可能会让你输入接口的“初级目录”，在前后端分离的场景下需要用一些参数指定后端，因此实际上我并不喜欢用packerfuzzer自动测试，我喜欢提取出接口和后端后自己用burp的intruder去测试。因此这里有一个脚本用于处理packerfuzzer下载回来的JS文件
该脚本会匹配被单引号或者双引号包裹起来的字符串，如果字符串被/分割，则将其提取。所以能够很全面地提取js中的接口uri
packerfuzzer+接口脚本（下载+提取）

上图的这个网站，直接查看其前端并没有找到任何和app.js index.js  main.js等比较经典的和webpack相关的文件。然而查看burp的history，却发现该网站加载了app.js，并且unexpected information插件成功在其中匹配到了各种信息
在这种情况下，packerfuzzer可能在一定程度上失灵，但是unexpected information和findsomething却有可能找到我们需要的信息。

fuzz
比如说我们看到http://test.hack.com/api/test/admin/delete，那么是不是可以fuzz一下admin/create呢？

上面我们就分享了从JS中提取接口uri的一些方法，几个现成的工具组合着用就行。

# 接口拼接
通过前面的接口获取，我们可能找到一个/virsical-auth/oauth/token接口
but，我们抓包或者通过别的方法找到的完整请求/vsk/virsical-auth/oauth/token
那么如果我想通过WEB访问这个动作，应该访问的uri应该是：/vsk/virsical-auth/oauth/token
这时候我们猜测他的初级目录是/vsk
找到的其他接口也与/vsk拼接一下，构成完整路径（这就是路径拼接）
当然，所谓"初级路径可能是/vsk也可能是/vsk/virsical-auth/这需要我们测试了
当然实战中绝大部分都是黑盒的情况，你通过现有功能看到这么一个uri，其实也不一定能百分百判断到底哪个是初级uri，比方说上述情况。有可能是/vsk作为初级uri，亦可能是/vsk/virsical-auth/作为初级uri，这个需要靠经验来判断。如果你怕判断有误，最好的办法就是多拼接几次，
- 比如：
- http://test.com/vsk/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/oauth/ <---接口依次拼接在这后面

以此类推，不过一般比较少出现这种情况。上述是“初级目录”的情况，还有一种情况则是前后端分离。这个也很好理解。比方说你访问的网站是：
`http://admin.test.com/#/login然而负责提供服务的后端地址可能是：`
`http://api.admin.test.com/api/admin/login`
`http://admin.test.com:8080/api/admin/login
这些抓包都很容易看出来，就不赘述了。

有些提取到的“接口”uri比其它接口uri显著短得多，而且规则也不一样，很多时候你把他们与后端或者“初级路径”做拼接去请求，却发现直接404了，那么这种是什么呢？这些实际上大部分是前端uri，相信师傅们经常能看到

前后端分离，或者多个初级路径的情况，我们可以写正则匹配http或者https://开头的字符串
> 	其实也非常ez，因为他这些后端地址包括“初级路径”，肯定不是无中生有搞出来的，这些东西肯定都在JS里。比方说上面的那个多个初级路径的情况，在JS中大概率存放了一些地址：http://api.test.com/login/http://api.test.com/user/http://api.test.com/admin/当用户访问对应功能，比方说普通用户修改自己的密码，前端会取出：/userApi/changePwd然后和对应的地址做拼接：http://api.test.com/user/userApi/changePwd然后发起一次请求。因此我们上述提取接口，实际上就是提取了所有类似/userApi/changePwd这样的uri。我们要找后端也很简单，写个正则专门匹配http://或https://开头的字符串即可：   熊猫头也可以实现一部分这样的功能，还有Unexpected information插件

我们获取到所有可能的后端和初级路径之后，我比较喜欢的操作其实是采用笛卡尔积去依此拼接初级路径。简单来说：后端字典 接口字典
http://api1.test.com/                     /user/getinfo
http://api2.test.com/api/admin/            /user/register
 http://api2.test.com/api/                  /manager/changeSetting按照笛卡尔积拼接处理可以得到：
 
 - http://api1.test.com/user/getinfo   
- http://api1.test.com/user/register
- http://api1.test.com/manager/changeSetting
- http://api2.test.com/api/admin/user/getinfo   
- http://api2.test.com/api/admin/user/register
- http://api2.test.com/api/admin/manager/changeSetting
- http://api2.test.com/api/user/getinfo   
- http://api2.test.com/api/user/register
- http://api2.test.com/api/manager/changeSetting
然后我们把这个最终的列表丢给HTTPX之类的工具跑一遍，测测活，根据响应码和数据包长度去筛选出所有可用接口，管他什么后端、初级路径，一下就能找到了，要的就是笨办法！当然这一步要是乐意也可以用burp的Cluster bomb去搞，反正啥工具用得顺手就用啥工具去测活。
综上我们就简单介绍了怎么去提取后端，然后怎么去拼接测试
这些新的地址属于藏得比较深的资产，可以进一步进行全端口扫描，漏扫等

目录fuzz，递归，Tsojanscan、APIKIT等等插件，强烈推荐师傅们使用

还有就是，正则匹配，ak/sk，邮箱，手机号，身份证，ip，密码，注释

# 找参数
有了接口，不给他参数，一般接口是无法正常工作的
example：
开始之前还是先来看看找不到参数是怎样的情况。我们来模拟一下平时测试的流程。我们找到了一个接口，先以GET去访问。一般会提示405，或者回显GET not supported，就是请求方式不对。那我们改成POST或者其它请求方式试试。此时，如果出现415错误，或者回显application/x-www-form-urlencoded Not supported，那就需要换一下Content-Type，绝大部分情况下，只需要改成application/json，并加上json请求体即可，极少数情况下遇到过xml传参。然后？然后就没有然后了，这下，从响应中我们并不能推断出自己下一步要干什么，当然这里还有可能出现各种奇奇怪怪的异常和回显，比如参数缺失、参数验证失败等等总之，我们应该怎么去寻找参数呢？
![[Pasted image 20240922164955.png]]

arjun去fuzz参数名（多参数），burp爆破参数（多参数的话会很难搞）
除了这样傻傻的去FUZZ参数名，有没有什么方法能比较直白地获取到参数呢？当然是有的，既然网站的功能要正常调用这些接口，说明关键的参数肯定也写在JS里了，我们前文提到的各种工具都会告诉你提取的接口出自哪个JS文件

一个比较有效的寻找参数名的方法就是回到JS原文，先定位到接口在JS代码中的位置，再去分析其前后文，寻找一些比较类似参数名的字符串，然后尝试去测试即可。
那我们就点进对应js文件，搜索部分接口uri，去定位前后文。比如上面的接口dev-api/system/pass/get/email/code
![[Pasted image 20240922165822.png]]
首先离他最近的，是不是就指示了它的传参是get模式。Ok，现在知道传参类型了。那么参数名呢？我们还是在这个接口的周围去看，发现离他最近的有个这个
![[Pasted image 20240922165917.png]]
![[Pasted image 20240922165928.png]]
注意看这几个东西，userName、tenantCode、code、newPassword，这几个东西是不是就特别像参数名？那我们直接来试一试，首先不带参数访问
![[Pasted image 20240922170012.png]]
加上刚才的参数？
![[Pasted image 20240922170018.png]]虽然可能因为一些参数值没写好，所以也没有调用成功，但通过返回结果的变化，说明我们已经找对参数名了，后续再FUZZ参数值即可

## 将js拆分成大字典进行fuzz
上面我们介绍了通过分析JS前后文去寻找参数名，但是有些时候，参数名并不会老老实实的放在目标接口的前后文，各种写法和风格千奇百怪，有时候参数名相关的部分可能和接口相关的部分隔得很远，如果JS基础不好是很难看出来的（更何况这些JS代码没有格式化，密密麻麻的更难看懂）。这种情况下对于不会JS的玩家还有没有什么比较友好的操作呢？当然有，既然参数值无论如何也会在JS里，还有种办法是粗暴地把你下载回来的所有JS文件打散成参数字典，
```
核心正则如下：matches = re.findall(r'[a-zA-Z]+[\w-]*\d*|\d+[\w-]*[a-zA-Z]+|[a-zA-Z]+\.[a-zA-Z]+|\w+\.\d+|[a-zA-Z]+~[a-zA-Z]+|\w+~\d+|\d+-\d+|[a-zA-Z]+-[a-zA-Z]+', line)
```
可以用这个正则替换我在上一篇文章的文末给出的小脚本中的正则，实现提取参数的效果，效果类似下面这样：
![[Pasted image 20240922171037.png]]结合前文提到的Burp或者Arjun进行参数FUZZ即可，虽然也比较耗时耗力，但是成功率还是要高上一些。

## 输入输出找参数
返回商品信息的接口和编辑商品信息的接口，它们操作的对象都是“商品”，那么这两个接口涉及到的参数有极大可能是完全一致的，比方说商品名、价格、商品描述等属性，就算有不一致的参数也会是少数，所以，当操作的类对象一样的时候。参数可以参考

同样去操作userDTO对应的用户属性，实现一个删除用户信息的效果？那假如我要获取用户信息呢？是不是同样也是从数据库查询到用户信息后，生成一个userDTO用户对象，然后将这个对象中的属性返回给用户呢？而最有意思的是，在很多java网站中，输出相关的接口（比如返回商品信息）返回的数据基本都会包含属性（参数名）。这也就意味着，如果我们的输入相关接口（如编辑商品信息）找不到参数名，可以去输出相关接口里找。同时输出相关的接口，其参数一般都比较简单，比较好fuzz，比如提到的/api/shop/selectinfo，也许只需要商品名之类的简单参数。我们可以先观察接口名字，找一组“输入输出接口”，当输入相关接口fuzz不出参数，可以找寻对应的输出相关接口，FUZZ其参数，然后通过观察接口返回的信息，来获取具体的参数值，多说无益，我们来给一个案例。

### 案例
挖掘到了一个接口，根据其名字，是编辑学校信息相关的：
![[Pasted image 20240922172824.png]]
比较难受，找不到参数名，经过fuzz也没有结果。根据“输入输出”这一思想的指导，如果我们把学校信息视作一个类，我们上面有编辑（输入）学校信息相关的接口，那应该也会有输出学校学校信息相关的接口。可以筛查出：
![[Pasted image 20240922172919.png]]
访问该接口，实际上可以看到很多东西：
![[Pasted image 20240922172938.png]]
注意这些fullTeacherAvgPeriod、sso、logo，根据上述理论，这些应该就对应学校信息类中的某些属性，很有可能作为/edit接口的参数，我们直接把这个返回包中的关键部分，粘贴到输入接口去利用，会怎么样呢？
![[Pasted image 20240922173039.png]]成功调用。
# 参数收集之长期建设
前文我们依次介绍了几种搜集参数的方法，其实我们的视角是在不断拓宽的，一开始我们搜集参数纯粹是以攻击者的视角来看待这个问题，后面慢慢拓展到以开发者的视角来看待这个问题。其实还可以再拓宽一点，比较正规一点的开发团队、项目，内部肯定是有很多开发上的规定的，其中当然也包括参数的命名规范、规律。同一个公司的不同业务的各个接口用到的参数，会有相似之处，甚至是相同。因此我们要对某个目标进行长时间的深入测试，其实可以准备一些burp插件，把平时关于该目标相关资产的请求、响应中出现的参数名保存下来，就可以生成一个专属目标的参数名字典。这样，当我们遇到和该目标有关的缺失参数名的测试场景时，就可以用这个专属参数名字典去进行参数的FUZZ了。
Github上也能找到一些干这个事的插件，例如：https://github.com/Giftedboy/ParasCollector

# 修改前端uri鉴权逻辑测试接口未鉴权问题
比如上图中的/login、/menu/list等等，这些都是前端uri。这时候就很开心，我直接进行一个拼接。比如说：http://test.com/#/loginhttp://test.com/login尝试拼接一个http://test.com/#/menu/listhttp://test.com/menu/list尝试去访问这些别的前端uri，看看能不能访问到对应的页面。这样一般也会有三种情况，第一种是目标站点没有任何对前端uri的鉴权。我们这么去访问，能直接看到页面，也不会给你跳转啥的，这时候就可以调用页面上的功能去抓包，分析这些功能点对应的接口的问题了。第二种情况稍微好点，就是你这么去访问，有概率看到要访问的页面闪一下，然后给你重定向回登录页面，这种时候有种拼手速的玩法，在重定向回登录页面之前，浏览器上的刷新按钮会变成这个状态：![[Pasted image 20240922174002.png]]
在他重定向回去之前，快速点一下这个X，那么后续动作就会终止执行，你的页面就会卡住。这时候我们也是开启burp愉快抓包就行。其实就是阻止重定向的思路。

第三种情况就是，我们没法看到想访问的页面，前端要么没反应，要么给你弹出个没有权限，要么直接重定向到/login登录页。这种时候我们又该怎么测试呢？下面的内容就需要一点前端调试和JS分析的基础了，本文不会深入展开，仅作案例介绍。假设这么一个网站，我们提取出一个前端uri为/home （很常见）

案例：