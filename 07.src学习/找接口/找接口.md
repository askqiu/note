webpack压缩js，用packerfuzzer，这个工具会把所有js文件保存到tmp目录中
python PackerFuzzer.py -u https://*** -f 1

由于packerfuzzer在自动测试过程中可能会让你输入接口的“初级目录”，在前后端分离的场景下需要用一些参数指定后端，因此实际上我并不喜欢用packerfuzzer自动测试，我喜欢提取出接口和后端后自己用burp的intruder去测试。因此这里有一个脚本用于处理packerfuzzer下载回来的JS文件
该脚本会匹配被单引号或者双引号包裹起来的字符串，如果字符串被/分割，则将其提取。所以能够很全面地提取js中的接口uri
packerfuzzer+接口脚本（下载+提取）

上图的这个网站，直接查看其前端并没有找到任何和app.js index.js  main.js等比较经典的和webpack相关的文件。然而查看burp的history，却发现该网站加载了app.js，并且unexpected information插件成功在其中匹配到了各种信息
在这种情况下，packerfuzzer可能在一定程度上失灵，但是unexpected information和findsomething却有可能找到我们需要的信息。

fuzz
比如说我们看到http://test.hack.com/api/test/admin/delete，那么是不是可以fuzz一下admin/create呢？

上面我们就分享了从JS中提取接口uri的一些方法，几个现成的工具组合着用就行。

# 接口拼接
通过前面的接口获取，我们可能找到一个/virsical-auth/oauth/token接口
but，我们抓包或者通过别的方法找到的完整请求/vsk/virsical-auth/oauth/token
那么如果我想通过WEB访问这个动作，应该访问的uri应该是：/vsk/virsical-auth/oauth/token
这时候我们猜测他的初级目录是/vsk
找到的其他接口也与/vsk拼接一下，构成完整路径（这就是路径拼接）
当然，所谓"初级路径可能是/vsk也可能是/vsk/virsical-auth/这需要我们测试了
当然实战中绝大部分都是黑盒的情况，你通过现有功能看到这么一个uri，其实也不一定能百分百判断到底哪个是初级uri，比方说上述情况。有可能是/vsk作为初级uri，亦可能是/vsk/virsical-auth/作为初级uri，这个需要靠经验来判断。如果你怕判断有误，最好的办法就是多拼接几次，
- 比如：
- http://test.com/vsk/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/ <---接口依次拼接在这后面
- http://test.com/vsk/virsical-auth/oauth/ <---接口依次拼接在这后面

以此类推，不过一般比较少出现这种情况。上述是“初级目录”的情况，还有一种情况则是前后端分离。这个也很好理解。比方说你访问的网站是：
`http://admin.test.com/#/login然而负责提供服务的后端地址可能是：`
`http://api.admin.test.com/api/admin/login`
`http://admin.test.com:8080/api/admin/login
这些抓包都很容易看出来，就不赘述了。

有些提取到的“接口”uri比其它接口uri显著短得多，而且规则也不一样，很多时候你把他们与后端或者“初级路径”做拼接去请求，却发现直接404了，那么这种是什么呢？这些实际上大部分是前端uri，相信师傅们经常能看到

前后端分离，或者多个初级路径的情况，我们可以写正则匹配http或者https://开头的字符串
> 	其实也非常ez，因为他这些后端地址包括“初级路径”，肯定不是无中生有搞出来的，这些东西肯定都在JS里。比方说上面的那个多个初级路径的情况，在JS中大概率存放了一些地址：http://api.test.com/login/http://api.test.com/user/http://api.test.com/admin/当用户访问对应功能，比方说普通用户修改自己的密码，前端会取出：/userApi/changePwd然后和对应的地址做拼接：http://api.test.com/user/userApi/changePwd然后发起一次请求。因此我们上述提取接口，实际上就是提取了所有类似/userApi/changePwd这样的uri。我们要找后端也很简单，写个正则专门匹配http://或https://开头的字符串即可：   熊猫头也可以实现一部分这样的功能，还有Unexpected information插件

我们获取到所有可能的后端和初级路径之后，我比较喜欢的操作其实是采用笛卡尔积去依此拼接初级路径。简单来说：后端字典 接口字典
http://api1.test.com/                     /user/getinfo
http://api2.test.com/api/admin/            /user/register
 http://api2.test.com/api/                  /manager/changeSetting按照笛卡尔积拼接处理可以得到：
 
 - http://api1.test.com/user/getinfo   
- http://api1.test.com/user/register
- http://api1.test.com/manager/changeSetting
- http://api2.test.com/api/admin/user/getinfo   
- http://api2.test.com/api/admin/user/register
- http://api2.test.com/api/admin/manager/changeSetting
- http://api2.test.com/api/user/getinfo   
- http://api2.test.com/api/user/register
- http://api2.test.com/api/manager/changeSetting
然后我们把这个最终的列表丢给HTTPX之类的工具跑一遍，测测活，根据响应码和数据包长度去筛选出所有可用接口，管他什么后端、初级路径，一下就能找到了，要的就是笨办法！当然这一步要是乐意也可以用burp的Cluster bomb去搞，反正啥工具用得顺手就用啥工具去测活。
这些新的地址属于藏得比较深的资产，可以进一步进行全端口扫描